The File system is made up of several interrelated data structures.

Unlike real 1970's disk, we are not going to concern ourselves with heads, tracks, sectors and blocks.
Rather we will treat the disk as a randomably addressable space of 256 byte blocks, with each block having
a 16 bit address, for a total of 16MB of storage. (This may sound tiny, but in the 1970's this would have
been a luxury for a home pc)

1: Bitmap, a block of disk space which every bit corresponds on a block of the disk. For 16MB disk we need a total of 32 256b blocks to map the entire disk. As we reserve the first 3 blocks for OS boot and system data/variables, the first Bitmap block is block 3.
2: Inode structure. At this level each 'filename' is just a 16b number and points to an Inode. The Inode structure stores basic information about the file, such as length and number of hard links. But most importantly it stores a list of blocks that make up the file.
3: Filenames are just a simple data file which maps text filenames to inode numbers. the OS will keep track of a conception Al structure called the 'root' inode, which will point to a formatted data file that will store the filenames and other extended data. In presentation this will be called the '.' file and some of the filenames store in it, could be poiting at other inode files which act as directories. It a function of the command interpiter and the fileio system to combine these into the concept of a hyiarchials filesystem.


------
Inode Structure
ID: int16
LINK_COUNT: int16 (Zero means inode is free and not assigned)
PERMISSION: int16 bit map of permissions. Read Right to Left, lowest to highest rwxISDX
            if I (0x4) set, then is parent to additional inodes rather than file.
	    if S (0x8) set, Special file for soft links, space for index used for additional data
	    if D (0x16) set, Device file, space for index used for additional data
	    if X (0x32) set, this is an extended inode list. Another INode points here for overflow.
CREATETIME: int32 (Time format for future library)
INDEXCNT: int16, how many block ranges are used in this inode. If zero then mark as Free or deleted.
1..INDEXCNT {NODE,SIZE).. : Points to 1 to SIZE disk nodes as this part of full file.
      If NODE == 0 then SIZE is int16 pointer to another inode (X type) for overflow.
Max Size without overflow is 60


----------------
bitmap structures
Main bitmap is just that 32 blocks of storage where each active bit means a block is in use.
To help reduce the fragmention of the disk, in Block 2 a 32 byte structure will keep track of
32 cursors that will a







old notes follow:

Our Disk File System is Very Basic and resembles some of the very early 1970's disk OS's
Some Very elementary concepts are borrowed from Unix like OS's but this is Far Far Far from a Unix like system
It is not going to even try to be one.

Disk loading is done by a short program, a boot loader, that started as address 00
   Boot loader
      Disk is seen as a sequential series of 256 byte blocks, Each block can be addressed by a 16bit index.
      (Max of 16MB disk)
      Block 0 is the Disk ID and if the Disk is Boot-able, the first two characters must be 'BO'
      Boot loading does following
      	   Reads block 0, stored at address 0x80
	           Structure is:
		   0-1: "BO"
		   2-0xe: Comment, Disk ID String ("BOOT Ver 1.0--")
		   0xf: null(0)
		   0x10-0x11: Number of blocks to load
		   0x12-0x13: First address to load
		   0x14-0x15: Entry Point to execute
		   0x16-0x17: If Zero, will prompt user for numerical value as a startup paramater
		   0x80-0xff: An optional string that will print printed on screen. (Null Terminated)
		   
		   
The First program should act as a stub with sufficent code to load and read the first inode and use that to find
the init program.

Right After the first two blocks used for stub loading, the next 8K storage (32x256b blocks) is the Disk's BitMask

The BitMask uses 1's to indicate FREE and 0's to indicate in use. (So formating of disk must fill this block with
1's, except for 0 and 1 of first word for the first reserve blocks.) Data format is little endin, so bit 0 of word 0
is for block 0, and bit 4 of word 1, is for block 20. etc etc. We are using 1's to indicate 'free' as it take a few
fewer instrucitons to test for possitive masks than negative masks when looking for a free spot in the mask.







